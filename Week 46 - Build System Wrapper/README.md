# Week 46: Build System Wrapper

## Project Overview
Create a build system wrapper that simplifies and enhances CMake with additional utilities and automation.

## Learning Objectives
- Build system design
- CMake scripting
- Dependency management
- Cross-platform building
- Build optimization
- Package management integration

## Features to Implement
- [ ] Project scaffolding/templates
- [ ] Simplified configuration
- [ ] Dependency fetching (conan, vcpkg)
- [ ] Build profiles (debug, release, etc.)
- [ ] Cross-compilation support
- [ ] Build caching
- [ ] Test execution integration
- [ ] Documentation generation
- [ ] Package creation
- [ ] CI/CD integration helpers

## Usage Example
```sh
# Create new project
./buildtool init myproject --template library

# Configure build
./buildtool config --build-type Release \
                   --compiler gcc \
                   --arch x64

# Add dependency
./buildtool add-dep boost --version 1.78

# Build project
./buildtool build

# Run tests
./buildtool test

# Create package
./buildtool package --format deb

# Clean build
./buildtool clean
```

## Project Configuration
```yaml
# build.yaml
project:
  name: MyLibrary
  version: 1.0.0
  language: C++
  standard: 17

dependencies:
  - name: boost
    version: ">=1.75"
    components: [filesystem, system]
  
  - name: gtest
    version: 1.11.0
    scope: test

targets:
  - name: mylib
    type: library
    sources: [src/**/*.cpp]
    headers: [include/**/*.h]
    include_dirs: [include]
    
  - name: myapp
    type: executable
    sources: [app/main.cpp]
    depends: [mylib]
    
  - name: tests
    type: test
    sources: [tests/**/*.cpp]
    depends: [mylib, gtest]

build_profiles:
  debug:
    flags: [-g, -O0, -DDEBUG]
    
  release:
    flags: [-O3, -DNDEBUG]
    lto: true
    
  sanitize:
    flags: [-fsanitize=address, -fsanitize=undefined]
```

## Implementation
```cpp
class BuildTool {
public:
    void init(const std::string& projectName,
              const std::string& template) {
        createDirectory(projectName);
        generateTemplate(projectName, template);
        initGit(projectName);
    }
    
    void configure(const BuildConfig& config) {
        std::string cmakeCmd = "cmake";
        cmakeCmd += " -DCMAKE_BUILD_TYPE=" + config.buildType;
        cmakeCmd += " -DCMAKE_CXX_COMPILER=" + config.compiler;
        cmakeCmd += " -B build";
        
        execute(cmakeCmd);
    }
    
    void build(const BuildOptions& opts) {
        std::string cmd = "cmake --build build";
        if (opts.parallel) {
            cmd += " -j" + std::to_string(
                std::thread::hardware_concurrency());
        }
        if (opts.verbose) {
            cmd += " --verbose";
        }
        
        execute(cmd);
    }
    
    void addDependency(const std::string& name,
                      const std::string& version) {
        // Use conan or vcpkg
        if (useConan_) {
            std::ofstream conanfile("conanfile.txt", 
                                   std::ios::app);
            conanfile << name << "/" << version << "\n";
            execute("conan install .");
        }
    }
};
```

## Generated CMakeLists.txt
```cmake
# Auto-generated by BuildTool
cmake_minimum_required(VERSION 3.15)
project(MyLibrary VERSION 1.0.0)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find dependencies
find_package(Boost 1.75 REQUIRED 
             COMPONENTS filesystem system)

# Library target
add_library(mylib
    src/mylib.cpp
    src/utils.cpp
)

target_include_directories(mylib PUBLIC
    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
    $<INSTALL_INTERFACE:include>
)

target_link_libraries(mylib PUBLIC
    Boost::filesystem
    Boost::system
)

# Executable
add_executable(myapp app/main.cpp)
target_link_libraries(myapp PRIVATE mylib)

# Tests
if(BUILD_TESTING)
    enable_testing()
    find_package(GTest REQUIRED)
    
    add_executable(tests tests/test_main.cpp)
    target_link_libraries(tests PRIVATE
        mylib
        GTest::gtest_main
    )
    
    add_test(NAME MyTests COMMAND tests)
endif()

# Installation
install(TARGETS mylib myapp
        EXPORT MyLibraryTargets
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib
        RUNTIME DESTINATION bin
)
```

## Key Concepts
- CMake scripting
- Dependency resolution
- Build system abstraction
- Package managers (conan, vcpkg)
- Cross-compilation
- Build caching (ccache, sccache)
- Toolchain files

## Extensions
- Add Docker integration
- Implement distributed builds
- Create build analytics
- Add artifact repository
- Implement incremental builds
- Create IDE project generation
- Add build visualization
- Implement build reproducibility
