# Week 9: Sorting Algorithm Visualizer

## Project Overview
Create a visual tool that demonstrates how different sorting algorithms work, either with ASCII art or graphical visualization.

## Learning Objectives
- Implementation of classic sorting algorithms
- Algorithm complexity analysis
- Visual representation of data
- Performance comparison
- Animation and timing control

## Features to Implement
- [ ] Bubble Sort visualization
- [ ] Selection Sort visualization
- [ ] Insertion Sort visualization
- [ ] Merge Sort visualization
- [ ] Quick Sort visualization
- [ ] Heap Sort visualization
- [ ] Adjustable array size
- [ ] Speed control for animation
- [ ] Step-by-step mode
- [ ] Comparison counter
- [ ] Swap counter
- [ ] Time measurement

## Algorithms to Include
- **Bubble Sort**: O(n²) - Simple comparison-based
- **Selection Sort**: O(n²) - Find minimum repeatedly
- **Insertion Sort**: O(n²) - Build sorted array gradually
- **Merge Sort**: O(n log n) - Divide and conquer
- **Quick Sort**: O(n log n) average - Partition-based
- **Heap Sort**: O(n log n) - Binary heap

## Visualization Example
```
[█████████░░░░░░░░░] - Sorting...
 1  2  3  4  5  6  7  8  9  10
Comparisons: 45 | Swaps: 23 | Time: 0.125s
```

## Key Concepts
- Time complexity analysis (Big O notation)
- Space complexity considerations
- Stable vs unstable sorting
- In-place vs out-of-place algorithms
- Divide and conquer strategies

## Extensions
- Add Radix Sort and Counting Sort
- Implement Shell Sort and Comb Sort
- Add sound effects for swaps
- Create side-by-side comparison mode
- Generate performance graphs
- Add worst/best/average case scenarios
